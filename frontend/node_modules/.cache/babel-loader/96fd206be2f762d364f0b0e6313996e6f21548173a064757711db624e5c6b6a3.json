{"ast":null,"code":"var _LocationService;\nimport { GOOGLE_MAPS_CONFIG } from '../config/google';\nclass LocationService {\n  constructor() {\n    this.geocoder = null;\n    this.watchId = null;\n  }\n  static getInstance() {\n    if (!LocationService.instance) {\n      LocationService.instance = new LocationService();\n    }\n    return LocationService.instance;\n  }\n\n  /**\n   * Initialize Google Maps services\n   */\n  async initialize() {\n    try {\n      var _window$google;\n      if (!((_window$google = window.google) !== null && _window$google !== void 0 && _window$google.maps)) {\n        const {\n          Loader\n        } = await import('@googlemaps/js-api-loader');\n        const loader = new Loader({\n          apiKey: GOOGLE_MAPS_CONFIG.API_KEY,\n          version: GOOGLE_MAPS_CONFIG.VERSION,\n          libraries: ['places', 'geometry']\n        });\n        await loader.load();\n      }\n      this.geocoder = new google.maps.Geocoder();\n    } catch (error) {\n      console.error('Failed to initialize Google Maps:', error);\n      throw new Error('Google Maps initialization failed');\n    }\n  }\n\n  /**\n   * Get current user location using browser geolocation\n   */\n  async getCurrentLocation(options) {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject({\n          code: -1,\n          message: 'Geolocation is not supported by this browser',\n          type: 'UNKNOWN'\n        });\n        return;\n      }\n      const defaultOptions = {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000,\n        // 5 minutes\n        ...options\n      };\n      navigator.geolocation.getCurrentPosition(async position => {\n        const location = {\n          lat: position.coords.latitude,\n          lng: position.coords.longitude\n        };\n        try {\n          // Enhance with reverse geocoding\n          const enhancedLocation = await this.reverseGeocode(location);\n          resolve(enhancedLocation);\n        } catch {\n          // Return basic location if reverse geocoding fails\n          resolve(location);\n        }\n      }, error => {\n        const locationError = {\n          code: error.code,\n          message: this.getGeolocationErrorMessage(error.code),\n          type: this.getGeolocationErrorType(error.code)\n        };\n        reject(locationError);\n      }, defaultOptions);\n    });\n  }\n\n  /**\n   * Watch user location for continuous updates\n   */\n  watchLocation(callback, errorCallback, options) {\n    if (!navigator.geolocation) {\n      const error = {\n        code: -1,\n        message: 'Geolocation is not supported by this browser',\n        type: 'UNKNOWN'\n      };\n      errorCallback === null || errorCallback === void 0 ? void 0 : errorCallback(error);\n      return -1;\n    }\n    const defaultOptions = {\n      enableHighAccuracy: true,\n      timeout: 10000,\n      maximumAge: 60000,\n      // 1 minute for watch\n      ...options\n    };\n    this.watchId = navigator.geolocation.watchPosition(async position => {\n      const location = {\n        lat: position.coords.latitude,\n        lng: position.coords.longitude\n      };\n      try {\n        const enhancedLocation = await this.reverseGeocode(location);\n        callback(enhancedLocation);\n      } catch {\n        callback(location);\n      }\n    }, error => {\n      const locationError = {\n        code: error.code,\n        message: this.getGeolocationErrorMessage(error.code),\n        type: this.getGeolocationErrorType(error.code)\n      };\n      errorCallback === null || errorCallback === void 0 ? void 0 : errorCallback(locationError);\n    }, defaultOptions);\n    return this.watchId;\n  }\n\n  /**\n   * Stop watching location\n   */\n  stopWatchingLocation() {\n    if (this.watchId !== null) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n    }\n  }\n\n  /**\n   * Reverse geocode coordinates to address\n   */\n  async reverseGeocode(location) {\n    if (!this.geocoder) {\n      await this.initialize();\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.geocoder) {\n        reject(new Error('Geocoder not initialized'));\n        return;\n      }\n      const latLng = new google.maps.LatLng(location.lat, location.lng);\n      this.geocoder.geocode({\n        location: latLng\n      }, (results, status) => {\n        if (status === 'OK' && results && results[0]) {\n          const result = results[0];\n          const enhancedLocation = {\n            ...location,\n            address: result.formatted_address\n          };\n\n          // Extract address components\n          result.address_components.forEach(component => {\n            const types = component.types;\n            if (types.includes('locality')) {\n              enhancedLocation.city = component.long_name;\n            } else if (types.includes('administrative_area_level_1')) {\n              enhancedLocation.state = component.short_name;\n            } else if (types.includes('country')) {\n              enhancedLocation.country = component.short_name;\n            } else if (types.includes('postal_code')) {\n              enhancedLocation.zipCode = component.long_name;\n            }\n          });\n          resolve(enhancedLocation);\n        } else {\n          reject(new Error(`Reverse geocoding failed: ${status}`));\n        }\n      });\n    });\n  }\n\n  /**\n   * Forward geocode address to coordinates\n   */\n  async forwardGeocode(address) {\n    if (!this.geocoder) {\n      await this.initialize();\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.geocoder) {\n        reject(new Error('Geocoder not initialized'));\n        return;\n      }\n      this.geocoder.geocode({\n        address\n      }, (results, status) => {\n        if (status === 'OK' && results) {\n          const locations = results.map(result => {\n            const location = {\n              lat: result.geometry.location.lat(),\n              lng: result.geometry.location.lng(),\n              address: result.formatted_address\n            };\n\n            // Extract address components\n            result.address_components.forEach(component => {\n              const types = component.types;\n              if (types.includes('locality')) {\n                location.city = component.long_name;\n              } else if (types.includes('administrative_area_level_1')) {\n                location.state = component.short_name;\n              } else if (types.includes('country')) {\n                location.country = component.short_name;\n              } else if (types.includes('postal_code')) {\n                location.zipCode = component.long_name;\n              }\n            });\n            return location;\n          });\n          resolve(locations);\n        } else {\n          reject(new Error(`Forward geocoding failed: ${status}`));\n        }\n      });\n    });\n  }\n\n  /**\n   * Calculate distance between two locations\n   */\n  calculateDistance(from, to, unit = 'miles') {\n    const R = unit === 'miles' ? 3959 : 6371; // Earth's radius\n    const dLat = this.toRadians(to.lat - from.lat);\n    const dLng = this.toRadians(to.lng - from.lng);\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(from.lat)) * Math.cos(this.toRadians(to.lat)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  /**\n   * Get location from IP address (fallback method)\n   */\n  async getLocationFromIP() {\n    try {\n      const response = await fetch('http://ipapi.co/json/');\n      const data = await response.json();\n      if (data.latitude && data.longitude) {\n        return {\n          lat: data.latitude,\n          lng: data.longitude,\n          city: data.city,\n          state: data.region_code,\n          country: data.country_code,\n          zipCode: data.postal\n        };\n      }\n      throw new Error('Invalid IP geolocation response');\n    } catch (error) {\n      console.error('IP geolocation failed:', error);\n      throw new Error('Failed to get location from IP');\n    }\n  }\n\n  /**\n   * Check if location permissions are granted\n   */\n  async checkLocationPermission() {\n    if (!navigator.permissions) {\n      return 'prompt'; // Assume prompt if Permissions API not available\n    }\n    try {\n      const permission = await navigator.permissions.query({\n        name: 'geolocation'\n      });\n      return permission.state;\n    } catch {\n      return 'prompt';\n    }\n  }\n  toRadians(degrees) {\n    return degrees * (Math.PI / 180);\n  }\n  getGeolocationErrorMessage(code) {\n    switch (code) {\n      case 1:\n        return 'Location access denied by user';\n      case 2:\n        return 'Location information unavailable';\n      case 3:\n        return 'Location request timed out';\n      default:\n        return 'Unknown location error';\n    }\n  }\n  getGeolocationErrorType(code) {\n    switch (code) {\n      case 1:\n        return 'PERMISSION_DENIED';\n      case 2:\n        return 'POSITION_UNAVAILABLE';\n      case 3:\n        return 'TIMEOUT';\n      default:\n        return 'UNKNOWN';\n    }\n  }\n}\n_LocationService = LocationService;\nLocationService.instance = void 0;\nexport default LocationService.getInstance();","map":{"version":3,"names":["GOOGLE_MAPS_CONFIG","LocationService","constructor","geocoder","watchId","getInstance","instance","initialize","_window$google","window","google","maps","Loader","loader","apiKey","API_KEY","version","VERSION","libraries","load","Geocoder","error","console","Error","getCurrentLocation","options","Promise","resolve","reject","navigator","geolocation","code","message","type","defaultOptions","enableHighAccuracy","timeout","maximumAge","getCurrentPosition","position","location","lat","coords","latitude","lng","longitude","enhancedLocation","reverseGeocode","locationError","getGeolocationErrorMessage","getGeolocationErrorType","watchLocation","callback","errorCallback","watchPosition","stopWatchingLocation","clearWatch","latLng","LatLng","geocode","results","status","result","address","formatted_address","address_components","forEach","component","types","includes","city","long_name","state","short_name","country","zipCode","forwardGeocode","locations","map","geometry","calculateDistance","from","to","unit","R","dLat","toRadians","dLng","a","Math","sin","cos","c","atan2","sqrt","getLocationFromIP","response","fetch","data","json","region_code","country_code","postal","checkLocationPermission","permissions","permission","query","name","degrees","PI","_LocationService"],"sources":["/Users/hz317604/Library/CloudStorage/OneDrive-TheHertzCorporation/Documents/Repos/CareConnect/frontend/src/services/locationService.ts"],"sourcesContent":["import { GOOGLE_MAPS_CONFIG } from '../config/google';\n\nexport interface Location {\n  lat: number;\n  lng: number;\n  address?: string;\n  city?: string;\n  state?: string;\n  country?: string;\n  zipCode?: string;\n}\n\nexport interface LocationError {\n  code: number;\n  message: string;\n  type: 'PERMISSION_DENIED' | 'POSITION_UNAVAILABLE' | 'TIMEOUT' | 'UNKNOWN';\n}\n\nclass LocationService {\n  private static instance: LocationService;\n  private geocoder: google.maps.Geocoder | null = null;\n  private watchId: number | null = null;\n\n  private constructor() {}\n\n  public static getInstance(): LocationService {\n    if (!LocationService.instance) {\n      LocationService.instance = new LocationService();\n    }\n    return LocationService.instance;\n  }\n\n  /**\n   * Initialize Google Maps services\n   */\n  public async initialize(): Promise<void> {\n    try {\n      if (!window.google?.maps) {\n        const { Loader } = await import('@googlemaps/js-api-loader');\n        const loader = new Loader({\n          apiKey: GOOGLE_MAPS_CONFIG.API_KEY,\n          version: GOOGLE_MAPS_CONFIG.VERSION,\n          libraries: ['places', 'geometry']\n        });\n        \n        await loader.load();\n      }\n      \n      this.geocoder = new google.maps.Geocoder();\n    } catch (error) {\n      console.error('Failed to initialize Google Maps:', error);\n      throw new Error('Google Maps initialization failed');\n    }\n  }\n\n  /**\n   * Get current user location using browser geolocation\n   */\n  public async getCurrentLocation(options?: PositionOptions): Promise<Location> {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject({\n          code: -1,\n          message: 'Geolocation is not supported by this browser',\n          type: 'UNKNOWN'\n        } as LocationError);\n        return;\n      }\n\n      const defaultOptions: PositionOptions = {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 300000, // 5 minutes\n        ...options\n      };\n\n      navigator.geolocation.getCurrentPosition(\n        async (position) => {\n          const location: Location = {\n            lat: position.coords.latitude,\n            lng: position.coords.longitude\n          };\n\n          try {\n            // Enhance with reverse geocoding\n            const enhancedLocation = await this.reverseGeocode(location);\n            resolve(enhancedLocation);\n          } catch {\n            // Return basic location if reverse geocoding fails\n            resolve(location);\n          }\n        },\n        (error) => {\n          const locationError: LocationError = {\n            code: error.code,\n            message: this.getGeolocationErrorMessage(error.code),\n            type: this.getGeolocationErrorType(error.code)\n          };\n          reject(locationError);\n        },\n        defaultOptions\n      );\n    });\n  }\n\n  /**\n   * Watch user location for continuous updates\n   */\n  public watchLocation(\n    callback: (location: Location) => void,\n    errorCallback?: (error: LocationError) => void,\n    options?: PositionOptions\n  ): number {\n    if (!navigator.geolocation) {\n      const error: LocationError = {\n        code: -1,\n        message: 'Geolocation is not supported by this browser',\n        type: 'UNKNOWN'\n      };\n      errorCallback?.(error);\n      return -1;\n    }\n\n    const defaultOptions: PositionOptions = {\n      enableHighAccuracy: true,\n      timeout: 10000,\n      maximumAge: 60000, // 1 minute for watch\n      ...options\n    };\n\n    this.watchId = navigator.geolocation.watchPosition(\n      async (position) => {\n        const location: Location = {\n          lat: position.coords.latitude,\n          lng: position.coords.longitude\n        };\n\n        try {\n          const enhancedLocation = await this.reverseGeocode(location);\n          callback(enhancedLocation);\n        } catch {\n          callback(location);\n        }\n      },\n      (error) => {\n        const locationError: LocationError = {\n          code: error.code,\n          message: this.getGeolocationErrorMessage(error.code),\n          type: this.getGeolocationErrorType(error.code)\n        };\n        errorCallback?.(locationError);\n      },\n      defaultOptions\n    );\n\n    return this.watchId;\n  }\n\n  /**\n   * Stop watching location\n   */\n  public stopWatchingLocation(): void {\n    if (this.watchId !== null) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n    }\n  }\n\n  /**\n   * Reverse geocode coordinates to address\n   */\n  public async reverseGeocode(location: Location): Promise<Location> {\n    if (!this.geocoder) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.geocoder) {\n        reject(new Error('Geocoder not initialized'));\n        return;\n      }\n\n      const latLng = new google.maps.LatLng(location.lat, location.lng);\n\n      this.geocoder.geocode({ location: latLng }, (results, status) => {\n        if (status === 'OK' && results && results[0]) {\n          const result = results[0];\n          const enhancedLocation: Location = {\n            ...location,\n            address: result.formatted_address\n          };\n\n          // Extract address components\n          result.address_components.forEach(component => {\n            const types = component.types;\n            \n            if (types.includes('locality')) {\n              enhancedLocation.city = component.long_name;\n            } else if (types.includes('administrative_area_level_1')) {\n              enhancedLocation.state = component.short_name;\n            } else if (types.includes('country')) {\n              enhancedLocation.country = component.short_name;\n            } else if (types.includes('postal_code')) {\n              enhancedLocation.zipCode = component.long_name;\n            }\n          });\n\n          resolve(enhancedLocation);\n        } else {\n          reject(new Error(`Reverse geocoding failed: ${status}`));\n        }\n      });\n    });\n  }\n\n  /**\n   * Forward geocode address to coordinates\n   */\n  public async forwardGeocode(address: string): Promise<Location[]> {\n    if (!this.geocoder) {\n      await this.initialize();\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.geocoder) {\n        reject(new Error('Geocoder not initialized'));\n        return;\n      }\n\n      this.geocoder.geocode({ address }, (results, status) => {\n        if (status === 'OK' && results) {\n          const locations: Location[] = results.map(result => {\n            const location: Location = {\n              lat: result.geometry.location.lat(),\n              lng: result.geometry.location.lng(),\n              address: result.formatted_address\n            };\n\n            // Extract address components\n            result.address_components.forEach(component => {\n              const types = component.types;\n              \n              if (types.includes('locality')) {\n                location.city = component.long_name;\n              } else if (types.includes('administrative_area_level_1')) {\n                location.state = component.short_name;\n              } else if (types.includes('country')) {\n                location.country = component.short_name;\n              } else if (types.includes('postal_code')) {\n                location.zipCode = component.long_name;\n              }\n            });\n\n            return location;\n          });\n\n          resolve(locations);\n        } else {\n          reject(new Error(`Forward geocoding failed: ${status}`));\n        }\n      });\n    });\n  }\n\n  /**\n   * Calculate distance between two locations\n   */\n  public calculateDistance(from: Location, to: Location, unit: 'miles' | 'kilometers' = 'miles'): number {\n    const R = unit === 'miles' ? 3959 : 6371; // Earth's radius\n    const dLat = this.toRadians(to.lat - from.lat);\n    const dLng = this.toRadians(to.lng - from.lng);\n    \n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n              Math.cos(this.toRadians(from.lat)) * Math.cos(this.toRadians(to.lat)) *\n              Math.sin(dLng / 2) * Math.sin(dLng / 2);\n    \n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  /**\n   * Get location from IP address (fallback method)\n   */\n  public async getLocationFromIP(): Promise<Location> {\n    try {\n      const response = await fetch('http://ipapi.co/json/');\n      const data = await response.json();\n      \n      if (data.latitude && data.longitude) {\n        return {\n          lat: data.latitude,\n          lng: data.longitude,\n          city: data.city,\n          state: data.region_code,\n          country: data.country_code,\n          zipCode: data.postal\n        };\n      }\n      \n      throw new Error('Invalid IP geolocation response');\n    } catch (error) {\n      console.error('IP geolocation failed:', error);\n      throw new Error('Failed to get location from IP');\n    }\n  }\n\n  /**\n   * Check if location permissions are granted\n   */\n  public async checkLocationPermission(): Promise<'granted' | 'denied' | 'prompt'> {\n    if (!navigator.permissions) {\n      return 'prompt'; // Assume prompt if Permissions API not available\n    }\n\n    try {\n      const permission = await navigator.permissions.query({ name: 'geolocation' });\n      return permission.state;\n    } catch {\n      return 'prompt';\n    }\n  }\n\n  private toRadians(degrees: number): number {\n    return degrees * (Math.PI / 180);\n  }\n\n  private getGeolocationErrorMessage(code: number): string {\n    switch (code) {\n      case 1:\n        return 'Location access denied by user';\n      case 2:\n        return 'Location information unavailable';\n      case 3:\n        return 'Location request timed out';\n      default:\n        return 'Unknown location error';\n    }\n  }\n\n  private getGeolocationErrorType(code: number): LocationError['type'] {\n    switch (code) {\n      case 1:\n        return 'PERMISSION_DENIED';\n      case 2:\n        return 'POSITION_UNAVAILABLE';\n      case 3:\n        return 'TIMEOUT';\n      default:\n        return 'UNKNOWN';\n    }\n  }\n}\n\nexport default LocationService.getInstance();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}