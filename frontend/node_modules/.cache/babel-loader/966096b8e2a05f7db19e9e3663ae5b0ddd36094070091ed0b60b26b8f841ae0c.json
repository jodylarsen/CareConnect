{"ast":null,"code":"var _AuthService;\nimport { GOOGLE_CONFIG, GOOGLE_OAUTH_URLS } from '../config/google';\nclass AuthService {\n  constructor() {\n    this.user = null;\n    this.tokens = null;\n    // Check for existing session on initialization\n    this.loadStoredAuth();\n  }\n  static getInstance() {\n    if (!AuthService.instance) {\n      AuthService.instance = new AuthService();\n    }\n    return AuthService.instance;\n  }\n\n  /**\n   * Initiate Google OAuth 2.0 login flow\n   */\n  login() {\n    const params = new URLSearchParams({\n      client_id: GOOGLE_CONFIG.CLIENT_ID,\n      redirect_uri: GOOGLE_CONFIG.REDIRECT_URI,\n      response_type: GOOGLE_CONFIG.RESPONSE_TYPE,\n      scope: GOOGLE_CONFIG.SCOPES.join(' '),\n      access_type: GOOGLE_CONFIG.ACCESS_TYPE,\n      prompt: GOOGLE_CONFIG.PROMPT,\n      state: this.generateState()\n    });\n\n    // Store state for validation\n    sessionStorage.setItem('oauth_state', params.get('state') || '');\n\n    // Redirect to Google OAuth\n    window.location.href = `${GOOGLE_OAUTH_URLS.AUTHORIZATION}?${params.toString()}`;\n  }\n\n  /**\n   * Handle OAuth callback with authorization code\n   */\n  async handleCallback(code, state) {\n    // Validate state parameter\n    const storedState = sessionStorage.getItem('oauth_state');\n    if (state !== storedState) {\n      throw new Error('Invalid state parameter');\n    }\n    try {\n      // Exchange authorization code for tokens\n      const tokens = await this.exchangeCodeForTokens(code);\n      this.tokens = tokens;\n\n      // Get user information\n      const user = await this.getUserInfo(tokens.access_token);\n      this.user = user;\n\n      // Store in session storage\n      this.storeAuth(user, tokens);\n\n      // Clean up\n      sessionStorage.removeItem('oauth_state');\n      return user;\n    } catch (error) {\n      console.error('OAuth callback error:', error);\n      throw new Error('Authentication failed');\n    }\n  }\n\n  /**\n   * Exchange authorization code for access tokens\n   */\n  async exchangeCodeForTokens(code) {\n    const response = await fetch(GOOGLE_OAUTH_URLS.TOKEN, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body: new URLSearchParams({\n        client_id: GOOGLE_CONFIG.CLIENT_ID,\n        client_secret: process.env.REACT_APP_GOOGLE_CLIENT_SECRET || '',\n        code,\n        grant_type: 'authorization_code',\n        redirect_uri: GOOGLE_CONFIG.REDIRECT_URI\n      })\n    });\n    if (!response.ok) {\n      throw new Error('Failed to exchange code for tokens');\n    }\n    return response.json();\n  }\n\n  /**\n   * Get user information from Google API\n   */\n  async getUserInfo(accessToken) {\n    const response = await fetch(GOOGLE_OAUTH_URLS.USER_INFO, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`\n      }\n    });\n    if (!response.ok) {\n      throw new Error('Failed to get user information');\n    }\n    return response.json();\n  }\n\n  /**\n   * Logout user and clear session\n   */\n  logout() {\n    this.user = null;\n    this.tokens = null;\n    sessionStorage.removeItem('careconnect_user');\n    sessionStorage.removeItem('careconnect_tokens');\n    sessionStorage.removeItem('oauth_state');\n  }\n\n  /**\n   * Get current user\n   */\n  getCurrentUser() {\n    return this.user;\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated() {\n    return this.user !== null && this.tokens !== null;\n  }\n\n  /**\n   * Get access token for API calls\n   */\n  getAccessToken() {\n    var _this$tokens;\n    return ((_this$tokens = this.tokens) === null || _this$tokens === void 0 ? void 0 : _this$tokens.access_token) || null;\n  }\n\n  /**\n   * Generate random state for OAuth security\n   */\n  generateState() {\n    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n  }\n\n  /**\n   * Store authentication data in session storage\n   */\n  storeAuth(user, tokens) {\n    sessionStorage.setItem('careconnect_user', JSON.stringify(user));\n    sessionStorage.setItem('careconnect_tokens', JSON.stringify(tokens));\n  }\n\n  /**\n   * Load stored authentication data\n   */\n  loadStoredAuth() {\n    try {\n      const storedUser = sessionStorage.getItem('careconnect_user');\n      const storedTokens = sessionStorage.getItem('careconnect_tokens');\n      if (storedUser && storedTokens) {\n        this.user = JSON.parse(storedUser);\n        this.tokens = JSON.parse(storedTokens);\n\n        // TODO: Validate token expiration and refresh if needed\n      }\n    } catch (error) {\n      console.error('Error loading stored auth:', error);\n      // Clear invalid stored data\n      this.logout();\n    }\n  }\n}\n_AuthService = AuthService;\nAuthService.instance = void 0;\nexport default AuthService.getInstance();","map":{"version":3,"names":["GOOGLE_CONFIG","GOOGLE_OAUTH_URLS","AuthService","constructor","user","tokens","loadStoredAuth","getInstance","instance","login","params","URLSearchParams","client_id","CLIENT_ID","redirect_uri","REDIRECT_URI","response_type","RESPONSE_TYPE","scope","SCOPES","join","access_type","ACCESS_TYPE","prompt","PROMPT","state","generateState","sessionStorage","setItem","get","window","location","href","AUTHORIZATION","toString","handleCallback","code","storedState","getItem","Error","exchangeCodeForTokens","getUserInfo","access_token","storeAuth","removeItem","error","console","response","fetch","TOKEN","method","headers","body","client_secret","process","env","REACT_APP_GOOGLE_CLIENT_SECRET","grant_type","ok","json","accessToken","USER_INFO","Authorization","logout","getCurrentUser","isAuthenticated","getAccessToken","_this$tokens","Math","random","substring","JSON","stringify","storedUser","storedTokens","parse","_AuthService"],"sources":["/Users/hz317604/Library/CloudStorage/OneDrive-TheHertzCorporation/Documents/Repos/CareConnect/frontend/src/services/auth.ts"],"sourcesContent":["import { GOOGLE_CONFIG, GOOGLE_OAUTH_URLS } from '../config/google';\n\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  picture: string;\n  verified_email: boolean;\n}\n\nexport interface AuthTokens {\n  access_token: string;\n  refresh_token?: string;\n  id_token?: string;\n  token_type: string;\n  expires_in: number;\n}\n\nclass AuthService {\n  private static instance: AuthService;\n  private user: User | null = null;\n  private tokens: AuthTokens | null = null;\n\n  private constructor() {\n    // Check for existing session on initialization\n    this.loadStoredAuth();\n  }\n\n  public static getInstance(): AuthService {\n    if (!AuthService.instance) {\n      AuthService.instance = new AuthService();\n    }\n    return AuthService.instance;\n  }\n\n  /**\n   * Initiate Google OAuth 2.0 login flow\n   */\n  public login(): void {\n    const params = new URLSearchParams({\n      client_id: GOOGLE_CONFIG.CLIENT_ID,\n      redirect_uri: GOOGLE_CONFIG.REDIRECT_URI,\n      response_type: GOOGLE_CONFIG.RESPONSE_TYPE,\n      scope: GOOGLE_CONFIG.SCOPES.join(' '),\n      access_type: GOOGLE_CONFIG.ACCESS_TYPE,\n      prompt: GOOGLE_CONFIG.PROMPT,\n      state: this.generateState()\n    });\n\n    // Store state for validation\n    sessionStorage.setItem('oauth_state', params.get('state') || '');\n    \n    // Redirect to Google OAuth\n    window.location.href = `${GOOGLE_OAUTH_URLS.AUTHORIZATION}?${params.toString()}`;\n  }\n\n  /**\n   * Handle OAuth callback with authorization code\n   */\n  public async handleCallback(code: string, state: string): Promise<User> {\n    // Validate state parameter\n    const storedState = sessionStorage.getItem('oauth_state');\n    if (state !== storedState) {\n      throw new Error('Invalid state parameter');\n    }\n\n    try {\n      // Exchange authorization code for tokens\n      const tokens = await this.exchangeCodeForTokens(code);\n      this.tokens = tokens;\n\n      // Get user information\n      const user = await this.getUserInfo(tokens.access_token);\n      this.user = user;\n\n      // Store in session storage\n      this.storeAuth(user, tokens);\n\n      // Clean up\n      sessionStorage.removeItem('oauth_state');\n\n      return user;\n    } catch (error) {\n      console.error('OAuth callback error:', error);\n      throw new Error('Authentication failed');\n    }\n  }\n\n  /**\n   * Exchange authorization code for access tokens\n   */\n  private async exchangeCodeForTokens(code: string): Promise<AuthTokens> {\n    const response = await fetch(GOOGLE_OAUTH_URLS.TOKEN, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: new URLSearchParams({\n        client_id: GOOGLE_CONFIG.CLIENT_ID,\n        client_secret: process.env.REACT_APP_GOOGLE_CLIENT_SECRET || '',\n        code,\n        grant_type: 'authorization_code',\n        redirect_uri: GOOGLE_CONFIG.REDIRECT_URI,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to exchange code for tokens');\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Get user information from Google API\n   */\n  private async getUserInfo(accessToken: string): Promise<User> {\n    const response = await fetch(GOOGLE_OAUTH_URLS.USER_INFO, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to get user information');\n    }\n\n    return response.json();\n  }\n\n  /**\n   * Logout user and clear session\n   */\n  public logout(): void {\n    this.user = null;\n    this.tokens = null;\n    sessionStorage.removeItem('careconnect_user');\n    sessionStorage.removeItem('careconnect_tokens');\n    sessionStorage.removeItem('oauth_state');\n  }\n\n  /**\n   * Get current user\n   */\n  public getCurrentUser(): User | null {\n    return this.user;\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  public isAuthenticated(): boolean {\n    return this.user !== null && this.tokens !== null;\n  }\n\n  /**\n   * Get access token for API calls\n   */\n  public getAccessToken(): string | null {\n    return this.tokens?.access_token || null;\n  }\n\n  /**\n   * Generate random state for OAuth security\n   */\n  private generateState(): string {\n    return Math.random().toString(36).substring(2, 15) + \n           Math.random().toString(36).substring(2, 15);\n  }\n\n  /**\n   * Store authentication data in session storage\n   */\n  private storeAuth(user: User, tokens: AuthTokens): void {\n    sessionStorage.setItem('careconnect_user', JSON.stringify(user));\n    sessionStorage.setItem('careconnect_tokens', JSON.stringify(tokens));\n  }\n\n  /**\n   * Load stored authentication data\n   */\n  private loadStoredAuth(): void {\n    try {\n      const storedUser = sessionStorage.getItem('careconnect_user');\n      const storedTokens = sessionStorage.getItem('careconnect_tokens');\n\n      if (storedUser && storedTokens) {\n        this.user = JSON.parse(storedUser);\n        this.tokens = JSON.parse(storedTokens);\n\n        // TODO: Validate token expiration and refresh if needed\n      }\n    } catch (error) {\n      console.error('Error loading stored auth:', error);\n      // Clear invalid stored data\n      this.logout();\n    }\n  }\n}\n\nexport default AuthService.getInstance();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}